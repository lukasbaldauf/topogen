import sys
import MDAnalysis as mda
from MDAnalysis.topology.guessers import guess_bonds,guess_angles,guess_dihedrals
import numpy as np


    
# force field params
def read_prm_file(prm_file):
    x=np.loadtxt(prm_file,dtype=str)
    x0_vals={} # equilibrium values
    K_vals={} # force constants
    for prm,x0,K in x[:,:]:
        x0_vals[prm]=float(x0)
        K_vals[prm]=float(K)
    return x0_vals,K_vals



def write_top(molname):
    with open(f"outfiles/{molname}.top","w") as wfile:
        wfile.write(f"""; Generated by topogen.py
#include "particle-types.itp"
#include "ions.itp" 
#include "{molname}.itp"

[ system ]
{molname}

[ molecules ]
{molname}    1
""")


def build_polymer(n_repeats,mol,backbone_selection,mer):
    res=mol.select_atoms('resid 1')
    n_atoms = n_repeats * res.n_atoms
    resindices = np.repeat(range(n_repeats), res.n_atoms/res.n_residues)
    assert len(resindices) == n_atoms
    
    segindices = [0] * n_repeats*res.residues.n_residues
    
    # Create an empty topology to be filled
    polymer = mda.Universe.empty(n_atoms,
                             n_residues=n_repeats*res.residues.n_residues,
                             atom_resindex=resindices,
                             residue_segindex=segindices,
                             trajectory=True) # necessary for adding coordinates
    
    # Add topology attributes
    bead_nr=np.concatenate([mol.select_atoms(f'resid {i%2+1}').names for i in range(n_repeats)])
    bead_mer=unpack(unpack([i*res.n_atoms for i in mer])).split()
    polymer.add_TopologyAttr('name',lists2str([bead_mer,bead_nr]))
    polymer.add_TopologyAttr('resname', [i for i in mer])
    polymer.add_TopologyAttr('resid',list(range(1,n_repeats*res.atoms.n_residues+1)))
    polymer.add_TopologyAttr('resnum',list(range(1,n_repeats*res.atoms.n_residues+1)))
    polymer.add_TopologyAttr('type', types*(n_repeats//2)+types[:3]*(n_repeats%2))
    polymer.add_TopologyAttr('mass',masses*(n_repeats//2)+masses[:3]*(n_repeats%2))
    polymer.add_TopologyAttr('charge',charge*(n_repeats//2)+charge[:3]*(n_repeats%2))
    
    # Add coordinates
    coordinates=[]
    backbone=mol.select_atoms('name 2 4').positions
    backbone_bond_vector=backbone[1]-backbone[0]
    for i in range(n_repeats):
        coordinates.extend(mol.atoms.select_atoms(f'resid {i%2+1}').positions+2*(i//2)*backbone_bond_vector)
    coord_array = np.array(coordinates)
    assert coord_array.shape == (n_atoms, 3)
    polymer.atoms.positions = coord_array
    
    # Add bonds, angles and dihedrals
    polymer_backbone=polymer.select_atoms(backbone_selection).indices
    print('Polymer backbone:',*id2nm([polymer_backbone],polymer),'\n')
    polymer.add_bonds([(polymer_backbone[i],polymer_backbone[i+1]) for i in range(len(polymer_backbone)-1)])
    polymer.add_bonds(guess_bonds(polymer.atoms,polymer.atoms.positions,vdwradii={type_:2.6 for type_ in polymer.atoms.types}))
    angles=guess_angles(polymer.bonds)
    polymer.add_angles(angles)
    dihedrals=guess_dihedrals(polymer.angles)
    polymer.add_dihedrals(dihedrals)
    
    return polymer


def gro2top(gro):
    res=mol.select_atoms('resid 1')
    n_atoms = n_repeats * res.n_atoms
    resindices = np.repeat(range(n_repeats), res.n_atoms/res.n_residues)
    assert len(resindices) == n_atoms
    
    segindices = [0] * n_repeats*res.residues.n_residues
    
    # Create an empty topology to be filled
    polymer = mda.Universe.empty(n_atoms,
                             n_residues=n_repeats*res.residues.n_residues,
                             atom_resindex=resindices,
                             residue_segindex=segindices,
                             trajectory=True) # necessary for adding coordinates
    
    # Add topology attributes
    bead_nr=np.concatenate([mol.select_atoms(f'resid {i%2+1}').names for i in range(n_repeats)])
    bead_mer=unpack(unpack([i*res.n_atoms for i in mer])).split()
    polymer.add_TopologyAttr('name',lists2str([bead_mer,bead_nr]))
    polymer.add_TopologyAttr('resname', [i for i in mer])
    polymer.add_TopologyAttr('resid',list(range(1,n_repeats*res.atoms.n_residues+1)))
    polymer.add_TopologyAttr('type', types*(n_repeats//2)+types[:3]*(n_repeats%2))
    polymer.add_TopologyAttr('mass',masses*(n_repeats//2)+masses[:3]*(n_repeats%2))
    polymer.add_TopologyAttr('charge',charge*(n_repeats//2)+charge[:3]*(n_repeats%2))
    
    # Add coordinates
    coordinates=[]
    backbone=mol.select_atoms('name 2 4').positions
    backbone_bond_vector=backbone[1]-backbone[0]
    for i in range(n_repeats):
        coordinates.extend(mol.atoms.select_atoms(f'resid {i%2+1}').positions+2*(i//2)*backbone_bond_vector)
    coord_array = np.array(coordinates)
    assert coord_array.shape == (n_atoms, 3)
    polymer.atoms.positions = coord_array
    
    # Add bonds, angles and dihedrals
    polymer_backbone=polymer.select_atoms(backbone_selection).indices
    print('Polymer backbone:',*id2nm([polymer_backbone],polymer))
    polymer.add_bonds([(polymer_backbone[i],polymer_backbone[i+1]) for i in range(len(polymer_backbone)-1)])
    polymer.add_bonds(guess_bonds(polymer.atoms,polymer.atoms.positions,vdwradii={type_:2.6 for type_ in polymer.atoms.types}))
    angles=guess_angles(polymer.bonds)
    polymer.add_angles(angles)
    dihedrals=guess_dihedrals(polymer.angles)
    polymer.add_dihedrals(dihedrals)
    
    return polymer

    
def id2nm(indxs,mol):
    """
    Convert list of indices to list of atom names.
    
    E.g. an angle defined by the atoms 
        [0,1,2] 
    is converted to the string 
        'B1-B2-B3'.
        
    It is important to note that order matters here. The bond 'B2-B4' is 
    generally different from 'B4-B2'.
    """
    names=[]
    for indx in indxs:
        names.append('-'.join([mol.atoms.names[i] for i in indx]))
    return names



def unpack(s,p="  "):
    return p.join(str(x) for x in s)

def lists2str(lists):
    out_list=[]
    len_=len(lists[0])
    for list_ in lists:
        assert len_==len(list_), 'Lists are not equal length'
        
    for i in range(len_):
        str_=''
        for list_ in lists:
            str_+=str(list_[i])
        out_list.append(str_)
    return out_list
            
                    
def write_moltype(wfile,molname,nrexcl):
    wfile.write('[ moleculetype ]\n')
    wfile.write('; molname nrexcl \n')
    wfile.write(f'{molname}  {nrexcl}\n')
    

def write_atoms(wfile,mol):
    wfile.write('\n[ atoms ] \n')
    wfile.write(';id type resnr residu atom cgnr charge mass \n')
    for atom in mol.atoms:
        wfile.write(f'{atom.index+1:<5} {atom.type:<5} {atom.resid:<5} {atom.resname:<5} {atom.name:<5} {atom.index+1:<5} {atom.charge:<7} {atom.mass:<7} \n')


def write_bonded(wfile,indices,mol,x0,K,bonded_type,fnc,period='',index=0):
    print(f'{"#"*10} {bonded_type[:-1].upper()+"S"} {"#"*10}')
    wfile.write(f'\n[ {bonded_type} ] \n')
    index.write(f'\n\n; {bonded_type} \n') 
    names=id2nm(indices,mol)
    missing=set()
    added=set()
    for i,(idx,name) in enumerate(zip(indices,names)):
        if name in x0.keys():
            added.add(name)
            wfile.write(f"{unpack(idx+1):<14} {fnc} {x0[name]:>10} {K[name]:>10} {period} ; {name} \n")
            if index:
                index.write(f"[ {name} ]\n{unpack(idx+1):<14}\n")
        elif bonded_type!='dihedrals':
            missing.add(name)
    if missing:
        print(f'  Missing {len(missing)} {bonded_type[:-1]} parameters:\n {missing}')
    else:
        print("Found all parameters")
    all_keys=set([x0i for x0i in x0.keys() if len(x0i.split('-'))==len(next(iter(added)).split('-'))])
    not_used=all_keys.difference(added)
    print('\n')
    

mer=sys.argv[1] #polymer composition. E.g. 'MGMGMGM' for an alginate or 'YYYYY' for a length 5 chitosan
molname=sys.argv[2] # the molecule name and output file name
gro='infiles/polymer-building-block.gro'

# ------------------------------------------------------
# Define the polymer building blocks
# ------------------------------------------------------
if 'M' in mer or 'G' in mer:
    # define topology
    bonds=[(0,1),(1,2),(1,3),(3,4),(3,5)]
    types=[ 'SQ5n', 'SN4','SP4', 'SN4', 'SQ5n', 'SP4']
    masses=[58.04,58.04,60.05,58.04,58.04,60.05]
    charge=[-1.00, 0.00, 0.00, 0.00,-1.00, 0.00]
    # load a monomer
    
elif 'Y' in mer:
    bonds=[(0,1),(1,2),(1,3),(3,4),(3,5)]
    types=['SP3','SN4','SQ5p','SN4','SP3','SQ5p']
    masses=[44.05,58.04,60.08,58.04,44.05,60.08]
    charge=[0.00,0.00,1.00,0.00,0.00,1.00]
# ------------------------------------------------------

mol = mda.Universe(gro)

backbone_selection='name '+' '.join([uniq + '2' for uniq in np.unique(unpack(mer).split())])
n_repeats = len(mer)
nrexcl=3
x0,K=read_prm_file('infiles/bonded-parameters.txt')


mol.add_bonds(bonds)
angles=guess_angles(mol.bonds)
mol.add_angles(angles)
dihedrals=guess_dihedrals(mol.angles)
mol.add_dihedrals(dihedrals)


pol=build_polymer(n_repeats,mol,backbone_selection,mer)


ndx=open(f"outfiles/{molname}.ndx","w")
with open(f"outfiles/{molname}.itp","w") as wfile:
    wfile.write(f"; mer\n; {mer}\n")
    write_moltype(wfile,molname,nrexcl)
    write_atoms(wfile,pol)
    write_bonded(wfile,pol.bonds.indices,pol,x0,K,'bonds',1,index=ndx)
    write_bonded(wfile,pol.angles.indices,pol,x0,K,'angles',2,index=ndx)
    write_bonded(wfile,pol.dihedrals.indices,pol,x0,K,'dihedrals',9,period='1',index=ndx)
    pol.atoms.write(f"outfiles/{molname}.gro")
ndx.close()
write_top(molname)

print("\n\n")
print("NOTE! Bonds with force constants of 30'000 should be converted to constraints.")
print("You may use the shell script 'bonds2constr.sh'")

